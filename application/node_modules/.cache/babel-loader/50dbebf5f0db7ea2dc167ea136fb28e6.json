{"ast":null,"code":"import _toConsumableArray from \"/home/malshanw/Documents/ColaProjects/orderapp/application/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\n// array in local storage for registered users\nvar users = JSON.parse(localStorage.getItem('users')) || [];\nexport function configureFakeBackend() {\n  var realFetch = window.fetch;\n\n  window.fetch = function (url, opts) {\n    return new Promise(function (resolve, reject) {\n      // wrap in timeout to simulate server api call\n      setTimeout(function () {\n        // authenticate\n        if (url.endsWith('/users/authenticate') && opts.method === 'POST') {\n          // get parameters from post request\n          var params = JSON.parse(opts.body); // find if any user matches login credentials\n\n          var filteredUsers = users.filter(function (user) {\n            return user.username === params.username && user.password === params.password;\n          });\n\n          if (filteredUsers.length) {\n            // if login details are valid return user details and fake jwt token\n            var user = filteredUsers[0];\n            var responseJson = {\n              id: user.id,\n              username: user.username,\n              firstName: user.firstName,\n              lastName: user.lastName,\n              token: 'fake-jwt-token'\n            };\n            resolve({\n              ok: true,\n              text: function text() {\n                return Promise.resolve(JSON.stringify(responseJson));\n              }\n            });\n          } else {\n            // else return error\n            reject('Username or password is incorrect');\n          }\n\n          return;\n        } // get users\n\n\n        if (url.endsWith('/users') && opts.method === 'GET') {\n          // check for fake auth token in header and return users if valid, this security is implemented server side in a real application\n          if (opts.headers && opts.headers.Authorization === 'Bearer fake-jwt-token') {\n            resolve({\n              ok: true,\n              text: function text() {\n                return Promise.resolve(JSON.stringify(users));\n              }\n            });\n          } else {\n            // return 401 not authorised if token is null or invalid\n            reject('Unauthorised');\n          }\n\n          return;\n        } // get user by id\n\n\n        if (url.match(/\\/users\\/\\d+$/) && opts.method === 'GET') {\n          // check for fake auth token in header and return user if valid, this security is implemented server side in a real application\n          if (opts.headers && opts.headers.Authorization === 'Bearer fake-jwt-token') {\n            // find user by id in users array\n            var urlParts = url.split('/');\n            var id = parseInt(urlParts[urlParts.length - 1]);\n            var matchedUsers = users.filter(function (user) {\n              return user.id === id;\n            });\n\n            var _user = matchedUsers.length ? matchedUsers[0] : null; // respond 200 OK with user\n\n\n            resolve({\n              ok: true,\n              text: function text() {\n                return JSON.stringify(_user);\n              }\n            });\n          } else {\n            // return 401 not authorised if token is null or invalid\n            reject('Unauthorised');\n          }\n\n          return;\n        } // register user\n\n\n        if (url.endsWith('/users/register') && opts.method === 'POST') {\n          // get new user object from post body\n          var newUser = JSON.parse(opts.body); // validation\n\n          var duplicateUser = users.filter(function (user) {\n            return user.username === newUser.username;\n          }).length;\n\n          if (duplicateUser) {\n            reject('Username \"' + newUser.username + '\" is already taken');\n            return;\n          } // save new user\n\n\n          newUser.id = users.length ? Math.max.apply(Math, _toConsumableArray(users.map(function (user) {\n            return user.id;\n          }))) + 1 : 1;\n          users.push(newUser);\n          localStorage.setItem('users', JSON.stringify(users)); // respond 200 OK\n\n          resolve({\n            ok: true,\n            text: function text() {\n              return Promise.resolve();\n            }\n          });\n          return;\n        } // delete user\n\n\n        if (url.match(/\\/users\\/\\d+$/) && opts.method === 'DELETE') {\n          // check for fake auth token in header and return user if valid, this security is implemented server side in a real application\n          if (opts.headers && opts.headers.Authorization === 'Bearer fake-jwt-token') {\n            // find user by id in users array\n            var _urlParts = url.split('/');\n\n            var _id = parseInt(_urlParts[_urlParts.length - 1]);\n\n            for (var i = 0; i < users.length; i++) {\n              var _user2 = users[i];\n\n              if (_user2.id === _id) {\n                // delete user\n                users.splice(i, 1);\n                localStorage.setItem('users', JSON.stringify(users));\n                break;\n              }\n            } // respond 200 OK\n\n\n            resolve({\n              ok: true,\n              text: function text() {\n                return Promise.resolve();\n              }\n            });\n          } else {\n            // return 401 not authorised if token is null or invalid\n            reject('Unauthorised');\n          }\n\n          return;\n        } // pass through any requests not handled above\n\n\n        realFetch(url, opts).then(function (response) {\n          return resolve(response);\n        });\n      }, 500);\n    });\n  };\n}","map":{"version":3,"sources":["/home/malshanw/Documents/ColaProjects/orderapp/application/src/_helpers/fake-backend.js"],"names":["users","JSON","parse","localStorage","getItem","configureFakeBackend","realFetch","window","fetch","url","opts","Promise","resolve","reject","setTimeout","endsWith","method","params","body","filteredUsers","filter","user","username","password","length","responseJson","id","firstName","lastName","token","ok","text","stringify","headers","Authorization","match","urlParts","split","parseInt","matchedUsers","newUser","duplicateUser","Math","max","map","push","setItem","i","splice","then","response"],"mappings":"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","sourcesContent":["// array in local storage for registered users\nlet users = JSON.parse(localStorage.getItem('users')) || [];\n    \nexport function configureFakeBackend() {\n    let realFetch = window.fetch;\n    window.fetch = function (url, opts) {\n        return new Promise((resolve, reject) => {\n            // wrap in timeout to simulate server api call\n            setTimeout(() => {\n\n                // authenticate\n                if (url.endsWith('/users/authenticate') && opts.method === 'POST') {\n                    // get parameters from post request\n                    let params = JSON.parse(opts.body);\n\n                    // find if any user matches login credentials\n                    let filteredUsers = users.filter(user => {\n                        return user.username === params.username && user.password === params.password;\n                    });\n\n                    if (filteredUsers.length) {\n                        // if login details are valid return user details and fake jwt token\n                        let user = filteredUsers[0];\n                        let responseJson = {\n                            id: user.id,\n                            username: user.username,\n                            firstName: user.firstName,\n                            lastName: user.lastName,\n                            token: 'fake-jwt-token'\n                        };\n                        resolve({ ok: true, text: () => Promise.resolve(JSON.stringify(responseJson)) });\n                    } else {\n                        // else return error\n                        reject('Username or password is incorrect');\n                    }\n\n                    return;\n                }\n\n                // get users\n                if (url.endsWith('/users') && opts.method === 'GET') {\n                    // check for fake auth token in header and return users if valid, this security is implemented server side in a real application\n                    if (opts.headers && opts.headers.Authorization === 'Bearer fake-jwt-token') {\n                        resolve({ ok: true, text: () => Promise.resolve(JSON.stringify(users))});\n                    } else {\n                        // return 401 not authorised if token is null or invalid\n                        reject('Unauthorised');\n                    }\n\n                    return;\n                }\n\n                // get user by id\n                if (url.match(/\\/users\\/\\d+$/) && opts.method === 'GET') {\n                    // check for fake auth token in header and return user if valid, this security is implemented server side in a real application\n                    if (opts.headers && opts.headers.Authorization === 'Bearer fake-jwt-token') {\n                        // find user by id in users array\n                        let urlParts = url.split('/');\n                        let id = parseInt(urlParts[urlParts.length - 1]);\n                        let matchedUsers = users.filter(user => { return user.id === id; });\n                        let user = matchedUsers.length ? matchedUsers[0] : null;\n\n                        // respond 200 OK with user\n                        resolve({ ok: true, text: () => JSON.stringify(user)});\n                    } else {\n                        // return 401 not authorised if token is null or invalid\n                        reject('Unauthorised');\n                    }\n\n                    return;\n                }\n\n                // register user\n                if (url.endsWith('/users/register') && opts.method === 'POST') {\n                    // get new user object from post body\n                    let newUser = JSON.parse(opts.body);\n\n                    // validation\n                    let duplicateUser = users.filter(user => { return user.username === newUser.username; }).length;\n                    if (duplicateUser) {\n                        reject('Username \"' + newUser.username + '\" is already taken');\n                        return;\n                    }\n\n                    // save new user\n                    newUser.id = users.length ? Math.max(...users.map(user => user.id)) + 1 : 1;\n                    users.push(newUser);\n                    localStorage.setItem('users', JSON.stringify(users));\n\n                    // respond 200 OK\n                    resolve({ ok: true, text: () => Promise.resolve() });\n\n                    return;\n                }\n\n                // delete user\n                if (url.match(/\\/users\\/\\d+$/) && opts.method === 'DELETE') {\n                    // check for fake auth token in header and return user if valid, this security is implemented server side in a real application\n                    if (opts.headers && opts.headers.Authorization === 'Bearer fake-jwt-token') {\n                        // find user by id in users array\n                        let urlParts = url.split('/');\n                        let id = parseInt(urlParts[urlParts.length - 1]);\n                        for (let i = 0; i < users.length; i++) {\n                            let user = users[i];\n                            if (user.id === id) {\n                                // delete user\n                                users.splice(i, 1);\n                                localStorage.setItem('users', JSON.stringify(users));\n                                break;\n                            }\n                        }\n\n                        // respond 200 OK\n                        resolve({ ok: true, text: () => Promise.resolve() });\n                    } else {\n                        // return 401 not authorised if token is null or invalid\n                        reject('Unauthorised');\n                    }\n\n                    return;\n                }\n\n                // pass through any requests not handled above\n                realFetch(url, opts).then(response => resolve(response));\n\n            }, 500);\n        });\n    }\n}"]},"metadata":{},"sourceType":"module"}